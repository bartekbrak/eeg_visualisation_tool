{# 
- id always refers to Bokeh model id,
- I try not to use jinja values inside JS calls, extracting them to variables first,
- in general flat is better than nested, extract what you can before you use it
#}
<script>

var evt = {}; // namespace
document.addEventListener('DOMContentLoaded', function() {
    // shortcuts
    var CDS = Bokeh.Collections('ColumnDataSource');
    evt = {
        video: document.querySelector('video'),
        hover_position: 0,
        progress: 0,
        // progress bar line y coordinates, two x values that are always bigger than the plot itself 
        line_y: {{ progress_bar_y }},
        progress_bar: CDS.get('{{ progress_bar_id }}'),
        // how often to redraw progress bar position in miliseconds
        update_resolution: 10,
        // all lines identified by their id
        lines: {},
        // grouper togglers relations
        groupers: {},
        // functions
        progress_bar_loop: function () {
            if (! evt.video.paused) evt.update_progress_bar()
            setTimeout(evt.progress_bar_loop, evt.update_resolution);
        },
        update_progress_bar: function () {
            evt.progress = parseInt(evt.video.currentTime * 1000);
            evt.progress_bar.set('data', {
                x: [evt.progress, evt.progress],
                y: evt.line_y
            });  
                // Bokeh.$("#timer").html(evt.fromSeconds(evt.video.currentTime));
                // evt.cur_index = parseInt((evt.video.currentTime / evt.video.duration) * y_series.length);
                // cur_value = y_series[evt.cur_index +1]
                // in_p = parseInt((cur_value - 0.560) / (1.127 - 0.560) * 100)
                //gauge.set(in_p);                      
        },
        line_toggle: function (input) {
            var id = Bokeh.$(input).data('id');
            var line = evt.lines[id];
            if (input.checked)
                line.cds.set('data', line.cds_orig_data);
            else
                line.cds.set('data', {});
        },
        toggle_video: function () {
            if (evt.video.paused) evt.video.play();
            else evt.video.pause();
        },
        rewind_to_hover: function () {
            evt.video.pause();
            evt.video.currentTime = evt.hover_position;
            evt.update_progress_bar();
        },
        // used for obsolete, custom timer
        fromSeconds: function (seconds) {
            var m = ('0' + Math.floor(seconds / 60)).slice(-2);
            var s = ('0' + parseInt(seconds % 60, 10)).slice(-2);
            var ms = ('' + (seconds % 1).toFixed(3)).slice(2, 5);
            if (isNaN(ms)) ms = '000';
            return m + ':' + s + ':' + ms
        }
    };

    Bokeh.$('.bk-plot-wrapper').each(function(index) {
        // Append legends to plots
        var legend = '#legend' + index;
        var plot_wrapper = '.bk-plot-wrapper:eq(' + index + ')';
        Bokeh.$(legend).appendTo(plot_wrapper);
    });


    {% for line_groups in line_groups_per_plot %}
        // Populate lines for further toggling
        {% for lines in line_groups.values() %}
            {% for line in lines %}
                var cds = CDS.get('{{ line.source._id }}');
                var id = '{{ line.source._id }}';
                evt.lines[id] = {cds: cds, cds_orig_data: cds.get('data')};
            {% endfor %}
        {% endfor %}
    {% endfor %}

    {% for total in totals %}
        var cds = CDS.get('{{ total.source._id }}');
        var id = '{{ total.source._id }}';    
        evt.lines[id] = {cds: cds, cds_orig_data: cds.get('data')};
    {% endfor %}

    // Toggler is an input connected with one line, grouper groups togglers
    Bokeh.$('input.grouper').each(function(index) {
        // Store grouper-toggler relation for later use 
        var group_name = Bokeh.$(this).data('group-name');
        var togglers = 'input.toggler[data-group-name="' + group_name + '"]'
        evt.groupers[group_name] = Bokeh.$(togglers);
    });     
    Bokeh.$('input.toggler').change(function() {evt.line_toggle(this); });
    Bokeh.$('input.grouper').change(function() {
        var group_name = Bokeh.$(this).data('group-name');
        evt.groupers[group_name].prop('checked', this.checked);
        evt.groupers[group_name].trigger('change');
    });  
    // Now make all lines visible in accordance to their input states
    Bokeh.$('input').trigger('change');


    // Mouse and keyobard events
    Bokeh.$('.bk-canvas-events').on('dblclick', evt.rewind_to_hover);
    window.addEventListener('keydown', function (event) {
        if (event.keyCode == 32) {
            evt.toggle_video();
            event.preventDefault();
        }
    });
    evt.video.addEventListener('mousedown', evt.toggle_video);
    // prevent leaving focus on the checkbox, we use space to toggle video 
    // which would also toggle the checkbox 
    Bokeh.$('input[type=checkbox]').mousedown(function (event) {
        event.preventDefault();
    });    

    // Start the main progress bar loop
    evt.progress_bar_loop();
    

});
</script>
