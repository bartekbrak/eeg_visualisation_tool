{# 
- id always refers to Bokeh model id,
- I try not to use jinja values inside JS calls, extracting them to variables first,
- in general flat is better than nested, extract what you can before you use it
#}
<script>{{ get_resource_as_string('static/gauge.js/dist/gauge.js') }}</script>
<script>

var evt = {}; // namespace
document.addEventListener('DOMContentLoaded', function() {
    // shortcuts
    var CDS = Bokeh.Collections('ColumnDataSource');
    $ = Bokeh.$;
    evt = {
        video: document.querySelector('video'),
        hover_position: 0,
        progress: 0,
        // progress bar line y coordinates, two x values that are always bigger than the plot itself 
        line_y: {{ progress_bar_y }},
        progress_bar: CDS.get('{{ progress_bar_id }}'),
        // how often to redraw progress bar position in miliseconds
        update_resolution: 10,
        // all lines identified by their id
        lines: {},
        // grouper togglers relations
        groupers: {},
        // HACK
        no_of_plots: $('.bk-plot-wrapper').length,
        // play /pause icon
        icon: $("#play-icon"),
        icons: $(".icons"),
        play_icon: $("#play-icon"),
        pause_icon: $("#pause-icon"),
        mouse_on_video: true,
        // functions
        progress_bar_loop: function () {
            if (! evt.video.paused) {
                evt.update_progress_bar();
                evt.move_gauges();
{#                $("#timer").html(evt.fromSeconds(evt.video.currentTime));#}
            };
            if (evt.mouse_on_video) {
                evt.icons.hide();
                evt.icon.show();
            } else evt.icons.hide();
            setTimeout(evt.progress_bar_loop, evt.update_resolution);
        },
        update_progress_bar: function () {
            evt.progress = parseInt(evt.video.currentTime * 1000);
            evt.progress_bar.set('data', {
                x: [evt.progress, evt.progress],
                y: evt.line_y
            });
        },
        line_toggle: function (input) {
            var id = $(input).data('id');
            var line = evt.lines[id];
            if (input.checked)
                line.cds.set('data', line.cds_orig_data);
            else
                line.cds.set('data', {});
        },
        toggle_video: function () {
            if (evt.video.paused) {
                evt.video.play();
                evt.icon = evt.pause_icon;
            } else {
                evt.video.pause()
                evt.icon = evt.play_icon;
            };
        },
        rewind_to_hover: function () {
            evt.video.pause();
            evt.video.currentTime = evt.hover_position;
            evt.update_progress_bar();
        },
        // used for obsolete, custom timer
        fromSeconds: function (seconds) {
            var m = ('0' + Math.floor(seconds / 60)).slice(-2);
            var s = ('0' + parseInt(seconds % 60, 10)).slice(-2);
            var ms = ('' + (seconds % 1).toFixed(3)).slice(2, 5);
            if (isNaN(ms)) ms = '000';
            return m + ':' + s + ':' + ms
        },
        gauges: {},
        move_gauges: function () {
            for (var i=0; i < evt.no_of_plots; i++) {
                var gauge = evt.gauges[i];
                var value = gauge['continuum'][evt.progress];
                if (value !== undefined) gauge['gauge'].set(value);
            }
        }
    };

    $('.bk-plot-wrapper').each(function(index) {
        // Append legends to plots, create gauges
        var gauge = $('#gauge' + index).get(0);
        evt.gauges[index] = {
            'gauge': new Gauge(gauge)
        };
        $('#legend' + index).appendTo($('.bk-plot-right:eq(' + index + ')'));
        $(gauge).appendTo('.bk-plot-left:eq(' + index + ')');
    });
    {% for total in totals %}
        var gauge = evt.gauges[{{ loop.index0 }}];
        gauge['mean'] = {{ total.mean }};
        gauge['continuum'] = {{ total.continuum }};
        gauge['gauge'].setOptions({
            threshold: {{ total.mean }},
            minValue : {{ total.min }},
            maxValue : {{ total.max }}
        });
        gauge['gauge'].set({{ total.mean }});
    {% endfor %}



    {% for line_groups in line_groups_per_plot %}
        // Populate lines for further toggling
        {% for lines in line_groups.values() %}
            {% for line in lines %}
                var cds = CDS.get('{{ line.source._id }}');
                var id = '{{ line.source._id }}';
                evt.lines[id] = {cds: cds, cds_orig_data: cds.get('data')};
            {% endfor %}
        {% endfor %}
    {% endfor %}

    {% for total in totals %}
        var cds = CDS.get('{{ total.source._id }}');
        var id = '{{ total.source._id }}';    
        evt.lines[id] = {cds: cds, cds_orig_data: cds.get('data')};
    {% endfor %}

    // Toggler is an input connected with one line, grouper groups togglers
    $('input.grouper').each(function(index) {
        // Store grouper-toggler relation for later use 
        var group_name = $(this).data('group-name');
        var togglers = 'input.toggler[data-group-name="' + group_name + '"]'
        evt.groupers[group_name] = $(togglers);
    });     
    $('input.toggler').change(function() {evt.line_toggle(this); });
    $('input.grouper').change(function() {
        var group_name = $(this).data('group-name');
        evt.groupers[group_name].prop('checked', this.checked);
        evt.groupers[group_name].trigger('change');
    });  
    // Now make all lines visible in accordance to their input states
    $('input').trigger('change');


    // Mouse and keyobard events
    $('.bk-canvas-events').on('dblclick', evt.rewind_to_hover);
    window.addEventListener('keydown', function (event) {
        if (event.keyCode == 32) {
            evt.toggle_video();
            event.preventDefault();
        }
    });
    // evt.video.addEventListener('mousedown', evt.toggle_video);
    $('#wideo_wrapper').hover(
        function() {
            evt.mouse_on_video = true;
        },
        function() {
            evt.mouse_on_video = false;
        }
    ).mousedown(evt.toggle_video);
    // prevent leaving focus on the checkbox, we use space to toggle video
    // which would also toggle the checkbox 
    $('input[type=checkbox]').mousedown(function (event) {
        event.preventDefault();
    });    

    // Start the main progress bar loop
    evt.progress_bar_loop();
    
});
</script>
